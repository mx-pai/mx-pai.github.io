<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>01背包问题</title>
    <link href="/2024/05/24/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2024/05/24/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>最近两周是程序设计实验周，现在过去了一周，这一周可谓是非常的烧脑，学习了很多算法的设计，这篇博客就作为，算法笔记的开篇</p><p>对于开发程序来说<code>程序 = 算法 + 数据结构</code>算法对于程序员极其重要，这篇博客就依次记录一个经典的<strong>动态规划问题：</strong></p><blockquote><p><strong>0/1背包</strong><br>给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。</p></blockquote><p>分析一下题目，每一件物体都有装和不装两个选项（这也是0/1的来源），如果暴力穷举的话，每一次都要去比较价值，就非常麻烦</p><p>于是这题采用的算法思路是一个很经典的动态规划（dynamic programing）的思想</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> weight[];<br><span class="hljs-type">int</span> value[];<br></code></pre></td></tr></table></figure><p>先确定dp数组和下标的含义</p><p><code>dp[i][j]表示从下标0-i的物品取任意物品放进容积为j的背包的价值总和</code></p><p>然后是推导<code>dp[i][j]</code>数组，已知每一个物体都有两种状态</p><ul><li><p>如果不放这个物体，那就代表<code>dp[i][j] = dp[i-1][j]</code>,<code>i-1</code>就代表不放这第i的物体</p></li><li><p>如果放了这个物体呢，那么此时的背包价值<code>dp[i][j]</code>就可以用<code>dp[i-1][j-weight[i]]+value[i]</code>表示，这个含义就是放<code>i</code>这个物体的价值+背包容量变为<code>j-weight[i]</code>时的价值</p></li></ul><p>所以如果要找到最大价值可以调用C++中的<code>#include&lt;algorithm&gt;</code>中的<code>max函数</code></p><p>所以即为</p><blockquote><p><code>dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])</code></p></blockquote><p>下一步是初始化数组</p><p>如果j为0，也就是背包容积为0，价值也一定为零，所以<code>dp[i][0]=0</code>，如果i为0，也就是放下标为0物体，价值也就是<code>value[0]</code>的价值，自己设置即可（当然也可以不这也初始化，全部初始化为零也行，因为最后比的是最大值）</p><p>所以具体代码实现过程为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= MaxWeight; j++)&#123;<br>            <span class="hljs-keyword">if</span>(j &gt;= w[i])&#123;<br>                dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j],dp[i<span class="hljs-number">-1</span>][j - weight[i]]+value[i]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这样看过来感觉很容易，但实际上问题就在于，到底代码的实现逻辑是什么？</p><p>就可以通过将<code>dp[i][j]数组打印出来</code>看看到底怎么回事</p><p><img src="/2024/05/24/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/image.png" alt="dm"></p><p>可以发现我是采用初始化全为0的方式，从第二行开始看，此时判断了放入重量为1的物体，总价值就是6，看看何时会改变，在第三行表示选择放入2的价值变化，从6 先变成了 7再变成了13，什么意思呢，当我发现我能放下 重量为 4的物体且此时背包价值刚好为7，背包如果再大的话就会加上物体1的价值，也就是13，剩下的思路也是如此分析</p><p>可以发现动态规划一个关键点是找到规划数组的方程，在这个二维方程的每一个位置都是储存了价值最大的状态，当往后选择时，就会调用前面的状态作比较，于是最终得到背包里的最大值</p><p>附上我的源代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">100</span>;<br><span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> MaxWeight = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> num;<br>    cout &lt;&lt; <span class="hljs-string">&quot;你要装多少物体\n&quot;</span>;<br>    cin &gt;&gt; num;<br>    <span class="hljs-type">int</span> v[num], w[num];<br>    cout &lt;&lt; <span class="hljs-string">&quot;输入每个物体的重量和价值(最大质量是10kg)\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++)&#123;<br>        cin &gt;&gt; w[i] &gt;&gt; v[i];<br>    &#125;<br>    <span class="hljs-type">int</span> dp[MAX][MAX] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= MaxWeight; j++)&#123;<br>            <span class="hljs-keyword">if</span>(j &gt;= w[i])&#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i<span class="hljs-number">-1</span>][j - w[i]]+v[i]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;能装的最大价值: &quot;</span> &lt;&lt; dp[num][MaxWeight] &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;背包装填状态详情\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= num; i++ )&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= MaxWeight;j++)&#123;<br>            cout &lt;&lt; dp[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    <span class="hljs-comment">//1 6 4 7 8 1 4 1 9 8测试集</span><br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interesting-AI</title>
    <link href="/2024/05/19/intertsting-AI/"/>
    <url>/2024/05/19/intertsting-AI/</url>
    
    <content type="html"><![CDATA[<h2 id="AI的逻辑推理">AI的逻辑推理</h2><p>前几天看到一个逻辑题</p><p><code>如果昨天是明天就好了，那么今天就是周五了。请问句子中的今天是周几 </code><br>这个问题很有意思，我第一反应是今天是周三，我没有聚焦在昨天而是聚焦在其中的逻辑当中，就是如果昨天是明天，此时的明天是今天的明天，我将这个今天的明天当成一个具体的星期数，也就是星期四，那么也就是说，昨天是周四的话，今天就是星期五。可实际上今天是星期三</p><p>然后我的朋友给我的回答是今天是星期日，“星期日”怎么来的？我感到很疑惑，然后仔细想想，如果把昨天是明天这句话的明天当成周五的明天，也是就是说是周六，那么今天不就是周五嘛，此时实际上昨天是周六，那么实际上今天是周日</p><p>可能我说的也是很绕口，但是归因下来就是看你如何将一个含糊的昨天当成周几了<br>然后下面的标准答案，我觉得更能让人理解</p><blockquote><p>如果昨天是明天就好了，那么今天就是周五了。请问今天实际是周几？</p></blockquote><ul><li><p>答案一：【昨天周二，今天周三，明天周四】潜台词： “哎，今天怎么才周三啊，如果昨天不是周二，而是周四就好了，这样今天就是周五了，周末马上就要开始了。”（下意识把抽象的“明天”替换成了具体的周四 )</p></li><li><p>答案二：【昨天周六，今天周日，明天周一】潜台词： “哎，今天周日这么快就要过去了啊，如果周六不是在昨天，而是在明天就好了，这样今天才周五，周末才刚要开始。”（下意识把抽象的&quot;昨天”替换成了具体的周六）这么读起来，似乎周三和周日两种答案都对。</p><blockquote><p>但实际上，读着没问题，是因为采用了“不是…而是”的表达方式，替换以后的句子是符合大家的表达信息与接受信息的习惯的，是一个没有歧义的、把特定值赋予抽象值的过程</p></blockquote></li></ul><p>此时你可能感到奇怪了，这和AI的逻辑推理有什么关系，时间来到今天下午，我突然想到哎，如果是AI来回答这种问题，它能答上来吗？<br>在日常生活中，我们对AI的使用越来越频繁，但是我们很少去问AI逻辑推理问题，于是说试就试，我一共找来了六种大模型，包含市面上的最强大的几款，先说结果吧，只有一个大模型回答正确，就是Chat-gpt4o</p><table><thead><tr><th>模型</th><th>回答</th></tr></thead><tbody><tr><td>Chat-gpt4o</td><td>假设今天是X天。根据题意：“如果昨天是明天就好了，那么今天就是周五了。” 我们分析以下几点： 昨天是明天。 今天是周五。我们从今天是周五出发，逆推一下： 如果今天是周五，那么昨天是周四。如果昨天是周四，但题目中说“昨天是明天”，这意味着周四其实是明天所以，今天实际是周三。总结：今天是周三。</td></tr><tr><td>Kimi</td><td>这个逻辑谜题可以通过以下步骤来解决：假设今天是周五。昨天就是周四。明天就是周六。现在，让我们根据句子中的逻辑来分析：句子说：“如果昨天是明天就好了”，这意味着我们希望昨天（周四）是明天。但是，根据正常的周次顺序，昨天不可能是明天。句子接着说：“那么今天就是周五了”，这暗示了如果我们按照句子中的条件（昨天是明天），今天（原本是周四）就会变成周五。所以，如果我们接受句子中的条件，那么今天实际上是周四。因为句子中的逻辑是在说，如果昨天（周四）是明天，那么今天（原本是周四）就会是周五。但现实中，昨天不可能是明天，所以今天仍然是周四。</td></tr><tr><td>智谱清言</td><td>这个问题实际上是一个逻辑谜题。首先，我们需要理解句子中的条件：“如果昨天是明天就好了”。这句话意味着如果昨天（通常是周四）实际上是明天（通常是周六），那么今天就会是周日。但是，由于这是一个假设，我们需要找到符合这个假设的实际日期。如果昨天是明天，那么今天实际上是在假设中的“明天”的前一天，即周五。然而，由于我们知道这个假设是不真实的，我们需要找到符合这个假设的真实日期。因此，如果今天是周五，那么昨天实际上是周四，而明天是周六。但是，我们需要将这个逻辑倒转回来，因为原句是一个未实现的愿望。所以，如果昨天是明天，那么今天实际上是在假设中的“明天”的前一天，即周五。现在，我们知道今天实际上是周五的“前一天”，即周四。但是，由于这是一个假设，我们需要再次倒转逻辑。如果昨天是明天，那么今天实际上是在假设中的“明天”的前一天，即周五。然而，由于我们知道这个假设是不真实的，我们需要找到符合这个假设的真实日期。因此，如果今天是周五，那么昨天实际上是周四，而明天是周六。但是，我们需要将这个逻辑倒转回来，因为原句是一个未实现的愿望。所以，如果昨天是明天，那么今天实际上是在假设中的“明天”的前一天，即周五。 现在，我们知道今天实际上是周五的“前一天”，即周四。但是，由于这是一个假设，我们需要再次倒转逻辑。如果昨天是明天，那么今天实际上是在假设中的“明天”的前一天，即周五。最终，我们可以得出结论，如果昨天是明天，那么今天实际上是在假设中的“明天”的前一天，即周五。因此，今天的实际日期是周五。</td></tr><tr><td>Claude-3</td><td>根据这个句子的逻辑: 如果昨天是明天就好了 那么今天就是周五了 这意味着,如果昨天是明天的话,那么今天就应该是周五。 但是,这只是一个假设性的情况。实际上,今天是什么具体的星期几,这个句子并没有明确说明。所以,我们无法确定句子中所说的&quot;今天&quot;到底是周几,因为这只是一个假设性的情况,并没有给出实际的今天是哪一天。</td></tr><tr><td>Mistral</td><td>抱歉，我无法理解你想表达什么。如果你问今天是星期几，我可以回答，但是我不能理解你的话语中的逻辑。根据常识，今天是星期日。</td></tr><tr><td>零一万物</td><td>这个句子是一个逻辑谜题，我们可以这样分析：  如果昨天是明天，那么今天就是昨天和明天之间的日子，即今天就是昨天和明天的中间一天。 如果今天是周五，那么昨天是周四，明天是周六。但是根据句子的假设，昨天是明天，所以周四就是周六，这是不可能的，因为周四和周六不是同一天。因此，我们需要找到一个日子，它的前一天是它的后一天的前一天。这样的日子只能是周五，因为周五的前一天是周四，后一天是周六。所以，如果昨天是明天，那么今天只能是周五。根据这个逻辑，句子中的“今天”是周五。</td></tr><tr><td>Chat-gpt3.5</td><td>如果我们根据题目假设“如果昨天是明天就好了，那么今天就是周五了”，我们可以逆推一下：如果今天是周五，那么昨天应该是周四。但是根据题目，“如果昨天是明天”，那么昨天应该是周五。所以，这个假设存在矛盾，无法成立。因此，无法确定今天实际是周几。</td></tr></tbody></table><p>看到结果，就是很想笑，有些AI不知道就不回答，有些AI利用自己的逻辑推理，一本正经的胡说八道，但是这个小实验也是存在很多问题的，它们的数据集参差不齐，对其推理的结果会有很大的影响，不过这也可以说明，一般的AI对于逻辑推理能力是个弱项，Chat-gpt4o之所以能回答出来，就是它的参数足够大，能力足够强（刚发布能不强吗）</p><p>但其实这些还不是AI的全部实力，我是完全基于没有提示词来询问的，如果你先给出AI的提示词，就比如：<code>你现在是一名逻辑推理大师，下面有个问题想问你，请你给出回答。</code> 有一个先决条件，AI会回答的很好，自己去试试吧 （笔者试过）</p><p>人工智能会超过人类吗，我觉得是可以的，两年时间，大模型如雨后春笋般冒出，在使用中我们也是看到了AI的实力的进步，就比如前几天的Open AI 和 Google 发布的新模型，给世人带来了新的震撼，从AI对话到AI生图，到去年的视频模型以及附带的一系列AI工具，以及如今的AI实时互动，AI已经与我们密不可分，其带来的能力也让我们受益无穷，我们必须学会使用AI也要学会利用AI，减少自己的工作流程，形成自己的工作流，减轻自己的工作量，<strong>AI再怎么强大，也是为人类服务的</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>观察</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>骑行之旅</title>
    <link href="/2024/05/18/bike/"/>
    <url>/2024/05/18/bike/</url>
    
    <content type="html"><![CDATA[<h2 id="歌德曾说过：“人之所以爱旅行，不是为了抵达目的地，而是为了享受旅途中的种种乐趣。”">歌德曾说过：“人之所以爱旅行，不是为了抵达目的地，而是为了享受旅途中的种种乐趣。”</h2><p>如果问我为什么想要旅行，我会说，我就是想去亲自看看。</p><p>蜗居宿舍已经长达12天，也是&quot;感谢&quot;学校的合理安排，这十二天过得也是可谓充实，每日都在为了任务不断地行动。很是反感如此的安排，但又身为一名学生，却又不好多说什么。依我看来，调休所带来的不仅仅是身体上的疲惫，还有那属于内心深处地不想被安排<code>自由不是想做什么就做什么，而是不想做什么就可以不做</code> 我们失去了选择，于是反感这样的安排，但仔细想想，哪有人不是被安排的呢，在于命运持续做抗争的我们，也只是命运之下的棋子罢了，清醒有时是原罪。</p><p>昨日突发奇想，骑行去玄武湖，打开手机一看</p><p><img src="/2024/05/18/bike/1d48dc104d01b90a563161ff392a205e899bcf8d.jpg" alt="tp"></p><p>不过去去18公里，这不手到擒来，于是乎计划定下来，忙忙碌碌中午午休过后，与舍友一同出发</p><p>对我而言，让我感兴趣的不是那终点的玄武湖，而是能在旅途中感受到与世界的联系</p><p><strong>中午阳光很大</strong>随身携带了一瓶矿泉水，路上也看到了以往乘坐地铁所看不到的风景</p><p><img src="/2024/05/18/bike/8314a09f2d9f530261a1b39d90eea006cac674f5.jpg" alt="tp">梧桐（南京典型）上面好像在输液，令我奇怪的是，今天竟然没有，梧桐的飞絮，当年宋美龄“一句梧桐美“老蒋”种满南京城”的故事现在更是流传，不过梧桐的美在深秋，梧桐的“痛”在初夏😁</p><p>中途绕过钟山北，也是远远望到了紫金山(南京最高 海拔448.9m)虽不算是很高，但其“钟山龙蟠，石城虎踞”的称号自古极富盛名</p><p><img src="/2024/05/18/bike/703cc50c73b3c4e87d650bb25e77a9d2c9a1f45b.jpg" alt="tp"></p><p>最后也是成功到达玄武湖</p><p><img src="/2024/05/18/bike/4ed1af56213b5d49e47223cd252dfc2d3a717976.jpg" alt="tp"></p><p>看了下哈喽单车的数据和地图所显示的18公里差距有点大呀，不愧是“缺德地图”导航，到底孰真孰假，也是无法精确考证了。也是花了有1个小时才骑到，但是给我带来的主观体感不如体测两千米😕 ,以后定个更远的距离，外出就是舒坦</p><p><img src="/2024/05/18/bike/a59fbee4c669300e035ff19cbd0a2815daf64685.jpg" alt="tp"></p><hr><p>说是旅行，其实不过是一场说走就走的骑行，但是过程总是自己深有体会的，是在公共交通下永远无法感受的自然，我觉得了解城市更重要的是用自己的脚步丈量着城市，我从家乡考到南京来，是自己的选择也是迫不得已的选择，去年，我将南京的景点基本上去了个遍，给我带来的感受不是很好，我感觉无法真正爱上这个城市，就现在而言，在闲逛，citywalk，骑行都走过这个城市时，我发现南京最大的特点就是包容，她不会在意你是谁，她能在你能所想到的一切条件下，充分给予你最大的便利，不要奢望她的科技，因为她就是因其历史与人文而存在</p><blockquote><p>身体与灵魂总得有一个在路上，或读万卷书，或行万里路，但不要停滞不前</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客</title>
    <link href="/2024/05/17/test1/"/>
    <url>/2024/05/17/test1/</url>
    
    <content type="html"><![CDATA[<h2 id="忙碌的下午">忙碌的下午</h2><p>上午高数课时，看到阮一峰大神的一篇博客文章<a href="https://jack-vanlightly.com/blog/2022/1/25/write-for-others-but-mostly-for-yourself">不要为别人写文章，而是要为自己而写</a>突然想起自己似乎丢下了一件一直想做的事情–写博客,几个月以前，我就想做这件事，然后去弄了框架，买了域名，当一切即将搞好的时候，我遇到了一个麻烦，我一直无法配置好我的Git Bash，我记得当时弄了好几天，最后实在不想弄了，于是这个想法被无限搁置。<br>记得前几天看到一本书里是这样说的</p><blockquote><p>不行是有机会做行的，而不做是永远不行的</p></blockquote><p>回顾我的生活过程中，我好像因为害怕的心理扔下了好几件事情：令我印象最深的就是大一时想去参加学校的辩论赛，其实我从初中就对这个很感兴趣，很想去在一个辩论的赛场上，尽情的发挥自己，但是结局是我报了名，在最后把自己的名字给删掉了，很好笑的是，我当时其实连辩论赛要穿的正装给买好了，直到现在那身衣服还在吃灰。后来我复盘时，我当时是咋想的嘞，好像就是怕了吧😢 ,我就在想如果是现在我会选择去参加吗？可惜没如果了哎</p><h2 id="奋起的高数课">奋起的高数课</h2><p>于是高数课时，我决定要改变，我在笔记里分析了已有的条件和手段，分析了思路，并彻底地理清了头绪</p><h2 id="悲催的下午">悲催的下午</h2><p>下午的课虽然没翘，但和翘课也没什么区别了，我决心要将这个博客网页给配置好，我先是删除了以前的文件，按照教程和官方文档重新安装，</p><blockquote><p>在此感谢这篇博文给我带来的极大帮助<a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站，史上最全教程_hexo博客-CSDN博客</a></p></blockquote><p>本来是一件很轻松的事情,但硬生生地耗费了我四个小时的时间去搭建,背后原因很是搞笑😂 我的配置时代码一直敲错</p><p><code>npm</code>一直敲成<code>nmp</code>,于是就一直报错,一直报错我就一直找教程,然后一直弄不好,真的是很崩溃😱</p><p>下午的课都已经结束了,我还没有弄好,当我都再次想放弃时,突然我发现我的代码出错了,改正回来时,<code>Enter</code>键一敲,成功了,真不知道是该开心还是伤心</p><h2 id="饿着肚子-一鼓作气">饿着肚子,一鼓作气</h2><p>前面的错误一经更改,之后的速度就很快了,照着教程很快就将之前所准备的条件和今天弄好的软件结合,最后也是成功搭建完成</p><p><img src="/2024/05/17/test1/2024-05-17-23-53-02-image.png" alt="tupian"></p><p>超级兴奋,最后的成品就是目前所看到的样子(也是经过很长时间的更改)</p><h2 id="回顾">回顾</h2><p>这次地网站搭建让我彻底理解了<code>去做</code>这件事,阻挡我们的有时候不是事情的困难,而是我们的踟蹰不前</p><ul><li>这次就写到这了,很晚了呀,好困😵</li></ul>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
