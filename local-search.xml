<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>525日</title>
    <link href="/2024/05/25/525%E6%97%A5/"/>
    <url>/2024/05/25/525%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>看到一个小故事，让我想起了之前看《被讨厌的勇气》时的感悟，结合今天的特殊日子：“我爱我”日，写一篇博客作为记录</p><blockquote><p>20多岁时，我跟一个长辈说：”我很担心，别人会怎么看待我做的那个决定。”长辈说：”放心吧，你没有观众的。”<br>现在想起来，我认为这是我得到过的最好建议。<br>– 阿曼达·福蒂尼（Amanda Fortini），美国作家</p></blockquote><p><strong>《被讨厌的勇气》</strong>的作者是日本作家岸见一郎与古贺史健，他们两人以对话的形式，通过青年与哲学家的对话，探讨了阿德勒心理学的核心理念，这本书鼓励人们面对内心的恐惧，接受自己的不完美，并且勇敢地追求自己的目标。</p><p>在此我不想对此书做过多叙述，我想通过书中的段落与今天的日子，来讲述我心中的阿德勒个体心理学</p><h2 id="原因论还是目的论"><a href="#原因论还是目的论" class="headerlink" title="原因论还是目的论"></a>原因论还是目的论</h2><p>一直以来，我听过也看到过各种言论，比如过去的原生家庭对自己造成了多大的伤害，小时候的心理创伤对长大造成了很严重的影响，我也对这种原因论深信不疑，认为一切结果都有原因，过去发生的一切塑造了如今的我。但是当我在阅读时，读到哲人一番与原因论绝然不同的观点：</p><blockquote><p>决定我们自身的不是过去的经历，而是我们自己赋予经历的意义</p></blockquote><p>他提到，我们给过去的经历“赋予了什么样的意义”，这直接决定了我们的生活，人生不是别人富裕的而是由自己选择的，是自己选择自己如何生活，进一步说，我们的不幸也是自己选择的，我起初的反应如同书中的青年：“啊，你在说什么，我自己选择不幸，这是什么谬论呀”，但当哲人继续说下去时，我逐渐明白了哲人所说的话</p><p>我们会时常想要做出改变时，这时我们会面临两种选择，一方面是保持“现在的我”，这听来可能会有点奇怪，我都想改变了，为何还有这个选择，那就是因为，但我们在面临另一个选择“新的生活方式”时，我们不知道这条路怎么走，前方的危险如何面对，会不会有更加不幸，更加痛苦的事情在以后，这时，“保持现在的我”的观点就会浮现，我们对如今的我面临的困难是了解的，如何解决也是知晓的，于是我们即使有各种不满，也会认为保持现状会更加安心</p><p>想要改变又害怕改变而导致没有发生改变就是阿德勒提出的我们自己选择的保持现状的目的造就了如今的我，我们之所以不幸，并不是因为过去或者环境，更不是能力不足，而是因为，我们<strong>缺乏”获得幸福的勇气“</strong></p><p>我们如果一直活在“如果怎样怎样”的假设中，我们就永远不会做出改变，我们只是在为自己找到不做改变的借口</p><h2 id="人生不是与他人的比赛"><a href="#人生不是与他人的比赛" class="headerlink" title="人生不是与他人的比赛"></a>人生不是与他人的比赛</h2><p>这让我想起了，从小到大我们一直被灌输的观点：谁谁谁怎么样，你要超过他，提高一分，干到千人……我们似乎一直被灌输着和他人作比较，与他人做竞争，当意识到竞争或胜负，那么势必就会产生自卑感，在不知不觉中，就会将他人乃至整个世界看作“敌人”，但事实上，别人真的会那么关注你吗，恐怕并非如此，“在意你脸的只有你自己”，这也是会导致自我意识的过剩，其实世上的人并不会关注我，即使我在大街上倒立也不会有人留意😆</p><p>如果站在竞争的角度考虑人际关系，我们很可能会将他人的成功当作我的失败，但如果我们将他人当作自己的伙伴，那么我们对世界的看法就会改变很<br>多，这个世界就变成了安全舒适的世界</p><h2 id="不要为满足别人的期待而活着"><a href="#不要为满足别人的期待而活着" class="headerlink" title="不要为满足别人的期待而活着"></a>不要为满足别人的期待而活着</h2><p>阿德勒心理学否定寻求他人的认可。我们“并不是为了满足别人的期待而活着”，他人也不是为了满足你的期待而活。如果一味地寻求别人的认可在意他人的评价，那最终就会活在别人的人生里</p><p>无论是希望特别优秀还是希望特别差劲，其目的都一样—为了引起别人的关注，脱离“普通的状态”、成为特别的存在。阿德勒称为“廉价的优越感追求”。我们根本没必要特意炫耀自己的优越性，要有甘于平凡的勇气。</p><p>但这并不是我们不去追求变好，没有远大目标，而是看到自己的此时此刻。比如人生就是为了到达山顶的登山，那么人生的大半时光都是在“路上”，也就是说，真正的人生就是登上山顶的时候，那之前的路上就只是临时的人生？</p><p>人生中的最大的谎言就是不活在此时此刻，只关注根本不存在的过去和未来就是我们对现在撒的一个弥天大谎，人生其实是一连续的刹那，起决定作用的是此时此刻的自己</p><h2 id="拥抱自己，要有被讨厌的勇气"><a href="#拥抱自己，要有被讨厌的勇气" class="headerlink" title="拥抱自己，要有被讨厌的勇气"></a>拥抱自己，要有被讨厌的勇气</h2><p>阿德勒心理学告诉我们应该从过去，未来以及人际关系中超脱出来，我们一直都有很自由，让我们一直裹足不前的其实是我们自己，我们要自我接纳，克服自卑，活出真实的自我，拥抱自己，找到真正的属于自己的幸福</p><hr><p>拙作一篇，欢迎提出建议</p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01背包问题</title>
    <link href="/2024/05/24/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2024/05/24/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>最近两周是程序设计实验周，现在过去了一周，这一周可谓是非常的烧脑，学习了很多算法的设计，这篇博客就作为，算法笔记的开篇</p><p>对于开发程序来说<code>程序 = 算法 + 数据结构</code>算法对于程序员极其重要，这篇博客就依次记录一个经典的<strong>动态规划问题：</strong></p><blockquote><p><strong>0&#x2F;1背包</strong><br>给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。</p></blockquote><p>分析一下题目，每一件物体都有装和不装两个选项（这也是0&#x2F;1的来源），如果暴力穷举的话，每一次都要去比较价值，就非常麻烦</p><p>于是这题采用的算法思路是一个很经典的动态规划（dynamic programing）的思想</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> weight[];<br><span class="hljs-type">int</span> value[];<br></code></pre></td></tr></table></figure><p>先确定dp数组和下标的含义</p><p><code>dp[i][j]表示从下标0-i的物品取任意物品放进容积为j的背包的价值总和</code></p><p>然后是推导<code>dp[i][j]</code>数组，已知每一个物体都有两种状态</p><ul><li><p>如果不放这个物体，那就代表<code>dp[i][j] = dp[i-1][j]</code>,<code>i-1</code>就代表不放这第i的物体</p></li><li><p>如果放了这个物体呢，那么此时的背包价值<code>dp[i][j]</code>就可以用<code>dp[i-1][j-weight[i]]+value[i]</code>表示，这个含义就是放<code>i</code>这个物体的价值+背包容量变为<code>j-weight[i]</code>时的价值</p></li></ul><p>所以如果要找到最大价值可以调用C++中的<code>#include&lt;algorithm&gt;</code>中的<code>max函数</code></p><p>所以即为</p><blockquote><p><code>dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])</code></p></blockquote><p>下一步是初始化数组</p><p>如果j为0，也就是背包容积为0，价值也一定为零，所以<code>dp[i][0]=0</code>，如果i为0，也就是放下标为0物体，价值也就是<code>value[0]</code>的价值，自己设置即可（当然也可以不这也初始化，全部初始化为零也行，因为最后比的是最大值）</p><p>所以具体代码实现过程为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= MaxWeight; j++)&#123;<br>            <span class="hljs-keyword">if</span>(j &gt;= w[i])&#123;<br>                dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j],dp[i<span class="hljs-number">-1</span>][j - weight[i]]+value[i]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这样看过来感觉很容易，但实际上问题就在于，到底代码的实现逻辑是什么？</p><p>就可以通过将<code>dp[i][j]数组打印出来</code>看看到底怎么回事</p><p><img src="/2024/05/24/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/image.png" alt="dm"></p><p>可以发现我是采用初始化全为0的方式，从第二行开始看，此时判断了放入重量为1的物体，总价值就是6，看看何时会改变，在第三行表示选择放入2的价值变化，从6 先变成了 7再变成了13，什么意思呢，当我发现我能放下 重量为 4的物体且此时背包价值刚好为7，背包如果再大的话就会加上物体1的价值，也就是13，剩下的思路也是如此分析</p><p>可以发现动态规划一个关键点是找到规划数组的方程，在这个二维方程的每一个位置都是储存了价值最大的状态，当往后选择时，就会调用前面的状态作比较，于是最终得到背包里的最大值</p><p>附上我的源代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">100</span>;<br><span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> MaxWeight = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> num;<br>    cout &lt;&lt; <span class="hljs-string">&quot;你要装多少物体\n&quot;</span>;<br>    cin &gt;&gt; num;<br>    <span class="hljs-type">int</span> v[num], w[num];<br>    cout &lt;&lt; <span class="hljs-string">&quot;输入每个物体的重量和价值(最大质量是10kg)\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++)&#123;<br>        cin &gt;&gt; w[i] &gt;&gt; v[i];<br>    &#125;<br>    <span class="hljs-type">int</span> dp[MAX][MAX] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= MaxWeight; j++)&#123;<br>            <span class="hljs-keyword">if</span>(j &gt;= w[i])&#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i<span class="hljs-number">-1</span>][j - w[i]]+v[i]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;能装的最大价值: &quot;</span> &lt;&lt; dp[num][MaxWeight] &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;背包装填状态详情\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= num; i++ )&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= MaxWeight;j++)&#123;<br>            cout &lt;&lt; dp[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    <span class="hljs-comment">//1 6 4 7 8 1 4 1 9 8测试集</span><br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interesting-AI</title>
    <link href="/2024/05/19/intertsting-AI/"/>
    <url>/2024/05/19/intertsting-AI/</url>
    
    <content type="html"><![CDATA[<h2 id="AI的逻辑推理"><a href="#AI的逻辑推理" class="headerlink" title="AI的逻辑推理"></a>AI的逻辑推理</h2><p>前几天看到一个逻辑题</p><p><code>如果昨天是明天就好了，那么今天就是周五了。请问句子中的今天是周几 </code><br>这个问题很有意思，我第一反应是今天是周三，我没有聚焦在昨天而是聚焦在其中的逻辑当中，就是如果昨天是明天，此时的明天是今天的明天，我将这个今天的明天当成一个具体的星期数，也就是星期四，那么也就是说，昨天是周四的话，今天就是星期五。可实际上今天是星期三</p><p>然后我的朋友给我的回答是今天是星期日，“星期日”怎么来的？我感到很疑惑，然后仔细想想，如果把昨天是明天这句话的明天当成周五的明天，也是就是说是周六，那么今天不就是周五嘛，此时实际上昨天是周六，那么实际上今天是周日</p><p>可能我说的也是很绕口，但是归因下来就是看你如何将一个含糊的昨天当成周几了<br>然后下面的标准答案，我觉得更能让人理解</p><blockquote><p>如果昨天是明天就好了，那么今天就是周五了。请问今天实际是周几？</p></blockquote><ul><li><p>答案一：【昨天周二，今天周三，明天周四】潜台词： “哎，今天怎么才周三啊，如果昨天不是周二，而是周四就好了，这样今天就是周五了，周末马上就要开始了。”（下意识把抽象的“明天”替换成了具体的周四 )</p></li><li><p>答案二：【昨天周六，今天周日，明天周一】潜台词： “哎，今天周日这么快就要过去了啊，如果周六不是在昨天，而是在明天就好了，这样今天才周五，周末才刚要开始。”（下意识把抽象的”昨天”替换成了具体的周六）这么读起来，似乎周三和周日两种答案都对。</p><blockquote><p>但实际上，读着没问题，是因为采用了“不是……而是”的表达方式，替换以后的句子是符合大家的表达信息与接受信息的习惯的，是一个没有歧义的、把特定值赋予抽象值的过程</p></blockquote></li></ul><p>此时你可能感到奇怪了，这和AI的逻辑推理有什么关系，时间来到今天下午，我突然想到哎，如果是AI来回答这种问题，它能答上来吗？<br>在日常生活中，我们对AI的使用越来越频繁，但是我们很少去问AI逻辑推理问题，于是说试就试，我一共找来了六种大模型，包含市面上的最强大的几款，先说结果吧，只有一个大模型回答正确，就是Chat-gpt4o</p><table><thead><tr><th>模型</th><th>回答</th></tr></thead><tbody><tr><td>Chat-gpt4o</td><td>假设今天是X天。根据题意：“如果昨天是明天就好了，那么今天就是周五了。” 我们分析以下几点： 昨天是明天。 今天是周五。我们从今天是周五出发，逆推一下： 如果今天是周五，那么昨天是周四。如果昨天是周四，但题目中说“昨天是明天”，这意味着周四其实是明天所以，今天实际是周三。总结：今天是周三。</td></tr><tr><td>Kimi</td><td>这个逻辑谜题可以通过以下步骤来解决：假设今天是周五。昨天就是周四。明天就是周六。现在，让我们根据句子中的逻辑来分析：句子说：“如果昨天是明天就好了”，这意味着我们希望昨天（周四）是明天。但是，根据正常的周次顺序，昨天不可能是明天。句子接着说：“那么今天就是周五了”，这暗示了如果我们按照句子中的条件（昨天是明天），今天（原本是周四）就会变成周五。所以，如果我们接受句子中的条件，那么今天实际上是周四。因为句子中的逻辑是在说，如果昨天（周四）是明天，那么今天（原本是周四）就会是周五。但现实中，昨天不可能是明天，所以今天仍然是周四。</td></tr><tr><td>智谱清言</td><td>这个问题实际上是一个逻辑谜题。首先，我们需要理解句子中的条件：“如果昨天是明天就好了”。这句话意味着如果昨天（通常是周四）实际上是明天（通常是周六），那么今天就会是周日。但是，由于这是一个假设，我们需要找到符合这个假设的实际日期。如果昨天是明天，那么今天实际上是在假设中的“明天”的前一天，即周五。然而，由于我们知道这个假设是不真实的，我们需要找到符合这个假设的真实日期。因此，如果今天是周五，那么昨天实际上是周四，而明天是周六。但是，我们需要将这个逻辑倒转回来，因为原句是一个未实现的愿望。所以，如果昨天是明天，那么今天实际上是在假设中的“明天”的前一天，即周五。现在，我们知道今天实际上是周五的“前一天”，即周四。但是，由于这是一个假设，我们需要再次倒转逻辑。如果昨天是明天，那么今天实际上是在假设中的“明天”的前一天，即周五。然而，由于我们知道这个假设是不真实的，我们需要找到符合这个假设的真实日期。因此，如果今天是周五，那么昨天实际上是周四，而明天是周六。但是，我们需要将这个逻辑倒转回来，因为原句是一个未实现的愿望。所以，如果昨天是明天，那么今天实际上是在假设中的“明天”的前一天，即周五。 现在，我们知道今天实际上是周五的“前一天”，即周四。但是，由于这是一个假设，我们需要再次倒转逻辑。如果昨天是明天，那么今天实际上是在假设中的“明天”的前一天，即周五。最终，我们可以得出结论，如果昨天是明天，那么今天实际上是在假设中的“明天”的前一天，即周五。因此，今天的实际日期是周五。</td></tr><tr><td>Claude-3</td><td>根据这个句子的逻辑: 如果昨天是明天就好了 那么今天就是周五了 这意味着,如果昨天是明天的话,那么今天就应该是周五。 但是,这只是一个假设性的情况。实际上,今天是什么具体的星期几,这个句子并没有明确说明。所以,我们无法确定句子中所说的”今天”到底是周几,因为这只是一个假设性的情况,并没有给出实际的今天是哪一天。</td></tr><tr><td>Mistral</td><td>抱歉，我无法理解你想表达什么。如果你问今天是星期几，我可以回答，但是我不能理解你的话语中的逻辑。根据常识，今天是星期日。</td></tr><tr><td>零一万物</td><td>这个句子是一个逻辑谜题，我们可以这样分析：  如果昨天是明天，那么今天就是昨天和明天之间的日子，即今天就是昨天和明天的中间一天。 如果今天是周五，那么昨天是周四，明天是周六。但是根据句子的假设，昨天是明天，所以周四就是周六，这是不可能的，因为周四和周六不是同一天。因此，我们需要找到一个日子，它的前一天是它的后一天的前一天。这样的日子只能是周五，因为周五的前一天是周四，后一天是周六。所以，如果昨天是明天，那么今天只能是周五。根据这个逻辑，句子中的“今天”是周五。</td></tr><tr><td>Chat-gpt3.5</td><td>如果我们根据题目假设“如果昨天是明天就好了，那么今天就是周五了”，我们可以逆推一下：如果今天是周五，那么昨天应该是周四。但是根据题目，“如果昨天是明天”，那么昨天应该是周五。所以，这个假设存在矛盾，无法成立。因此，无法确定今天实际是周几。</td></tr></tbody></table><p>看到结果，就是很想笑，有些AI不知道就不回答，有些AI利用自己的逻辑推理，一本正经的胡说八道，但是这个小实验也是存在很多问题的，它们的数据集参差不齐，对其推理的结果会有很大的影响，不过这也可以说明，一般的AI对于逻辑推理能力是个弱项，Chat-gpt4o之所以能回答出来，就是它的参数足够大，能力足够强（刚发布能不强吗）</p><p>但其实这些还不是AI的全部实力，我是完全基于没有提示词来询问的，如果你先给出AI的提示词，就比如：<code>你现在是一名逻辑推理大师，下面有个问题想问你，请你给出回答。</code> 有一个先决条件，AI会回答的很好，自己去试试吧 （笔者试过）</p><p>人工智能会超过人类吗，我觉得是可以的，两年时间，大模型如雨后春笋般冒出，在使用中我们也是看到了AI的实力的进步，就比如前几天的Open AI 和 Google 发布的新模型，给世人带来了新的震撼，从AI对话到AI生图，到去年的视频模型以及附带的一系列AI工具，以及如今的AI实时互动，AI已经与我们密不可分，其带来的能力也让我们受益无穷，我们必须学会使用AI也要学会利用AI，减少自己的工作流程，形成自己的工作流，减轻自己的工作量，<strong>AI再怎么强大，也是为人类服务的</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>观察</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>骑行之旅</title>
    <link href="/2024/05/18/bike/"/>
    <url>/2024/05/18/bike/</url>
    
    <content type="html"><![CDATA[<h2 id="歌德曾说过：“人之所以爱旅行，不是为了抵达目的地，而是为了享受旅途中的种种乐趣。”"><a href="#歌德曾说过：“人之所以爱旅行，不是为了抵达目的地，而是为了享受旅途中的种种乐趣。”" class="headerlink" title="歌德曾说过：“人之所以爱旅行，不是为了抵达目的地，而是为了享受旅途中的种种乐趣。”"></a>歌德曾说过：“人之所以爱旅行，不是为了抵达目的地，而是为了享受旅途中的种种乐趣。”</h2><p>如果问我为什么想要旅行，我会说，我就是想去亲自看看。</p><p>蜗居宿舍已经长达12天，也是”感谢”学校的合理安排，这十二天过得也是可谓充实，每日都在为了任务不断地行动。很是反感如此的安排，但又身为一名学生，却又不好多说什么。依我看来，调休所带来的不仅仅是身体上的疲惫，还有那属于内心深处地不想被安排<code>自由不是想做什么就做什么，而是不想做什么就可以不做</code> 我们失去了选择，于是反感这样的安排，但仔细想想，哪有人不是被安排的呢，在于命运持续做抗争的我们，也只是命运之下的棋子罢了，清醒有时是原罪。</p><p>昨日突发奇想，骑行去玄武湖，打开手机一看</p><p><img src="/2024/05/18/bike/1d48dc104d01b90a563161ff392a205e899bcf8d.jpg" alt="tp"></p><p>不过去去18公里，这不手到擒来，于是乎计划定下来，忙忙碌碌中午午休过后，与舍友一同出发</p><p>对我而言，让我感兴趣的不是那终点的玄武湖，而是能在旅途中感受到与世界的联系</p><p><strong>中午阳光很大</strong>随身携带了一瓶矿泉水，路上也看到了以往乘坐地铁所看不到的风景</p><p><img src="/2024/05/18/bike/8314a09f2d9f530261a1b39d90eea006cac674f5.jpg" alt="tp">梧桐（南京典型）上面好像在输液，令我奇怪的是，今天竟然没有，梧桐的飞絮，当年宋美龄“一句梧桐美“老蒋”种满南京城”的故事现在更是流传，不过梧桐的美在深秋，梧桐的“痛”在初夏:grin:</p><p>中途绕过钟山北，也是远远望到了紫金山(南京最高 海拔448.9m)虽不算是很高，但其“钟山龙蟠，石城虎踞”的称号自古极富盛名</p><p><img src="/2024/05/18/bike/703cc50c73b3c4e87d650bb25e77a9d2c9a1f45b.jpg" alt="tp"></p><p>最后也是成功到达玄武湖</p><p><img src="/2024/05/18/bike/4ed1af56213b5d49e47223cd252dfc2d3a717976.jpg" alt="tp"></p><p>看了下哈喽单车的数据和地图所显示的18公里差距有点大呀，不愧是“缺德地图”导航，到底孰真孰假，也是无法精确考证了。也是花了有1个小时才骑到，但是给我带来的主观体感不如体测两千米:confused: ,以后定个更远的距离，外出就是舒坦</p><p><img src="/2024/05/18/bike/a59fbee4c669300e035ff19cbd0a2815daf64685.jpg" alt="tp"></p><hr><p>说是旅行，其实不过是一场说走就走的骑行，但是过程总是自己深有体会的，是在公共交通下永远无法感受的自然，我觉得了解城市更重要的是用自己的脚步丈量着城市，我从家乡考到南京来，是自己的选择也是迫不得已的选择，去年，我将南京的景点基本上去了个遍，给我带来的感受不是很好，我感觉无法真正爱上这个城市，就现在而言，在闲逛，citywalk，骑行都走过这个城市时，我发现南京最大的特点就是包容，她不会在意你是谁，她能在你能所想到的一切条件下，充分给予你最大的便利，不要奢望她的科技，因为她就是因其历史与人文而存在</p><blockquote><p>身体与灵魂总得有一个在路上，或读万卷书，或行万里路，但不要停滞不前</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客</title>
    <link href="/2024/05/17/test1/"/>
    <url>/2024/05/17/test1/</url>
    
    <content type="html"><![CDATA[<h2 id="忙碌的下午"><a href="#忙碌的下午" class="headerlink" title="忙碌的下午"></a>忙碌的下午</h2><p>上午高数课时，看到阮一峰大神的一篇博客文章<a href="https://jack-vanlightly.com/blog/2022/1/25/write-for-others-but-mostly-for-yourself">不要为别人写文章，而是要为自己而写</a>突然想起自己似乎丢下了一件一直想做的事情–写博客,几个月以前，我就想做这件事，然后去弄了框架，买了域名，当一切即将搞好的时候，我遇到了一个麻烦，我一直无法配置好我的Git Bash，我记得当时弄了好几天，最后实在不想弄了，于是这个想法被无限搁置。<br>记得前几天看到一本书里是这样说的</p><blockquote><p>不行是有机会做行的，而不做是永远不行的</p></blockquote><p>回顾我的生活过程中，我好像因为害怕的心理扔下了好几件事情：令我印象最深的就是大一时想去参加学校的辩论赛，其实我从初中就对这个很感兴趣，很想去在一个辩论的赛场上，尽情的发挥自己，但是结局是我报了名，在最后把自己的名字给删掉了，很好笑的是，我当时其实连辩论赛要穿的正装给买好了，直到现在那身衣服还在吃灰。后来我复盘时，我当时是咋想的嘞，好像就是怕了吧:cry: ,我就在想如果是现在我会选择去参加吗？可惜没如果了哎</p><h2 id="奋起的高数课"><a href="#奋起的高数课" class="headerlink" title="奋起的高数课"></a>奋起的高数课</h2><p>于是高数课时，我决定要改变，我在笔记里分析了已有的条件和手段，分析了思路，并彻底地理清了头绪</p><h2 id="悲催的下午"><a href="#悲催的下午" class="headerlink" title="悲催的下午"></a>悲催的下午</h2><p>下午的课虽然没翘，但和翘课也没什么区别了，我决心要将这个博客网页给配置好，我先是删除了以前的文件，按照教程和官方文档重新安装，</p><blockquote><p>在此感谢这篇博文给我带来的极大帮助<a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站，史上最全教程_hexo博客-CSDN博客</a></p></blockquote><p>本来是一件很轻松的事情,但硬生生地耗费了我四个小时的时间去搭建,背后原因很是搞笑:joy: 我的配置时代码一直敲错</p><p><code>npm</code>一直敲成<code>nmp</code>,于是就一直报错,一直报错我就一直找教程,然后一直弄不好,真的是很崩溃:scream:</p><p>下午的课都已经结束了,我还没有弄好,当我都再次想放弃时,突然我发现我的代码出错了,改正回来时,<code>Enter</code>键一敲,成功了,真不知道是该开心还是伤心</p><h2 id="饿着肚子-一鼓作气"><a href="#饿着肚子-一鼓作气" class="headerlink" title="饿着肚子,一鼓作气"></a>饿着肚子,一鼓作气</h2><p>前面的错误一经更改,之后的速度就很快了,照着教程很快就将之前所准备的条件和今天弄好的软件结合,最后也是成功搭建完成</p><p><img src="/2024/05/17/test1/2024-05-17-23-53-02-image.png" alt="tupian"></p><p>超级兴奋,最后的成品就是目前所看到的样子(也是经过很长时间的更改)</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>这次地网站搭建让我彻底理解了<code>去做</code>这件事,阻挡我们的有时候不是事情的困难,而是我们的踟蹰不前</p><ul><li>这次就写到这了,很晚了呀,好困:dizzy_face:</li></ul>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
